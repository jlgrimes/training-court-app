// ignore_for_file: non_constant_identifier_names, camel_case_types, file_namesimport, file_names, unnecessary_null_comparison

// WARNING: This code is auto-generated by Supadart.
// WARNING: Modifications may be overwritten. Please make changes in the SudaDart configuration.

// SDK
import 'package:supabase_flutter/supabase_flutter.dart';

// No Intl package needed
// No Dart Convert needed
// Supadart Class
abstract class SupadartClass<T> {
  static Map<String, dynamic> insert(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  static Map<String, dynamic> update(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  factory SupadartClass.fromJson(Map<String, dynamic> json) {
    throw UnimplementedError();
  }

  static converter(List<Map<String, dynamic>> data) {
    throw UnimplementedError();
  }

  static converterSingle(Map<String, dynamic> data) {
    throw UnimplementedError();
  }
}

// Supabase Client Extension
extension SupadartClient on SupabaseClient {
  SupabaseQueryBuilder get tournaments => from('tournaments');
  SupabaseQueryBuilder get user_data => from('User_data');
  SupabaseQueryBuilder get pilot_users => from('pilot_users');
  SupabaseQueryBuilder get tournament_rounds => from('Tournament_rounds');
  SupabaseQueryBuilder get feedback => from('feedback');
  SupabaseQueryBuilder get logs => from('logs');
}

// Supabase Storage Client Extension
extension SupadartStorageClient on SupabaseStorageClient {}

// Enums

// Utils
class Tournaments implements SupadartClass<Tournaments> {
  final String id;
  final String name;
  final DateTime? createdAt;
  final String user;
  final DateTime? dateFrom;
  final DateTime? dateTo;
  final String? deck;
  final String? category;
  final String? placement;

  const Tournaments({
    required this.id,
    required this.name,
    this.createdAt,
    required this.user,
    this.dateFrom,
    this.dateTo,
    this.deck,
    this.category,
    this.placement,
  });

  static String get table_name => 'tournaments';
  static String get c_id => 'id';
  static String get c_name => 'name';
  static String get c_createdAt => 'created_at';
  static String get c_user => 'user';
  static String get c_dateFrom => 'date_from';
  static String get c_dateTo => 'date_to';
  static String get c_deck => 'deck';
  static String get c_category => 'category';
  static String get c_placement => 'placement';

  static List<Tournaments> converter(List<Map<String, dynamic>> data) {
    return data.map(Tournaments.fromJson).toList();
  }

  static Tournaments converterSingle(Map<String, dynamic> data) {
    return Tournaments.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? name,
    DateTime? createdAt,
    String? user,
    DateTime? dateFrom,
    DateTime? dateTo,
    String? deck,
    String? category,
    String? placement,
  }) {
    return {
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (user != null) 'user': user,
      if (dateFrom != null) 'date_from': dateFrom.toIso8601String(),
      if (dateTo != null) 'date_to': dateTo.toIso8601String(),
      if (deck != null) 'deck': deck,
      if (category != null) 'category': category,
      if (placement != null) 'placement': placement,
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String name,
    DateTime? createdAt,
    required String user,
    required DateTime dateFrom,
    required DateTime dateTo,
    String? deck,
    String? category,
    String? placement,
  }) {
    return _generateMap(
      id: id,
      name: name,
      createdAt: createdAt,
      user: user,
      dateFrom: dateFrom,
      dateTo: dateTo,
      deck: deck,
      category: category,
      placement: placement,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? name,
    DateTime? createdAt,
    String? user,
    DateTime? dateFrom,
    DateTime? dateTo,
    String? deck,
    String? category,
    String? placement,
  }) {
    return _generateMap(
      id: id,
      name: name,
      createdAt: createdAt,
      user: user,
      dateFrom: dateFrom,
      dateTo: dateTo,
      deck: deck,
      category: category,
      placement: placement,
    );
  }

  factory Tournaments.fromJson(Map<String, dynamic> jsonn) {
    return Tournaments(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      name: jsonn['name'] != null ? jsonn['name'].toString() : '',
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      user: jsonn['user'] != null ? jsonn['user'].toString() : '',
      dateFrom: jsonn['date_from'] != null
          ? DateTime.parse(jsonn['date_from'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      dateTo: jsonn['date_to'] != null
          ? DateTime.parse(jsonn['date_to'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      deck: jsonn['deck'] != null ? jsonn['deck'].toString() : '',
      category: jsonn['category'] != null ? jsonn['category'].toString() : '',
      placement:
          jsonn['placement'] != null ? jsonn['placement'].toString() : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      name: name,
      createdAt: createdAt,
      user: user,
      dateFrom: dateFrom,
      dateTo: dateTo,
      deck: deck,
      category: category,
      placement: placement,
    );
  }

  Tournaments copyWith({
    String? id,
    String? name,
    DateTime? createdAt,
    String? user,
    DateTime? dateFrom,
    DateTime? dateTo,
    String? deck,
    String? category,
    String? placement,
  }) {
    return Tournaments(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      user: user ?? this.user,
      dateFrom: dateFrom ?? this.dateFrom,
      dateTo: dateTo ?? this.dateTo,
      deck: deck ?? this.deck,
      category: category ?? this.category,
      placement: placement ?? this.placement,
    );
  }
}

class User_data implements SupadartClass<User_data> {
  final String id;
  final DateTime? createdAt;
  final String? avatar;
  final String? liveScreenName;

  const User_data({
    required this.id,
    this.createdAt,
    this.avatar,
    this.liveScreenName,
  });

  static String get table_name => 'User_data';
  static String get c_id => 'id';
  static String get c_createdAt => 'created_at';
  static String get c_avatar => 'avatar';
  static String get c_liveScreenName => 'live_screen_name';

  static List<User_data> converter(List<Map<String, dynamic>> data) {
    return data.map(User_data.fromJson).toList();
  }

  static User_data converterSingle(Map<String, dynamic> data) {
    return User_data.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    DateTime? createdAt,
    String? avatar,
    String? liveScreenName,
  }) {
    return {
      if (id != null) 'id': id,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (avatar != null) 'avatar': avatar,
      if (liveScreenName != null) 'live_screen_name': liveScreenName,
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    DateTime? createdAt,
    String? avatar,
    String? liveScreenName,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      avatar: avatar,
      liveScreenName: liveScreenName,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    DateTime? createdAt,
    String? avatar,
    String? liveScreenName,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      avatar: avatar,
      liveScreenName: liveScreenName,
    );
  }

  factory User_data.fromJson(Map<String, dynamic> jsonn) {
    return User_data(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      avatar: jsonn['avatar'] != null ? jsonn['avatar'].toString() : '',
      liveScreenName: jsonn['live_screen_name'] != null
          ? jsonn['live_screen_name'].toString()
          : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      avatar: avatar,
      liveScreenName: liveScreenName,
    );
  }

  User_data copyWith({
    String? id,
    DateTime? createdAt,
    String? avatar,
    String? liveScreenName,
  }) {
    return User_data(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      avatar: avatar ?? this.avatar,
      liveScreenName: liveScreenName ?? this.liveScreenName,
    );
  }
}

class PilotUsers implements SupadartClass<PilotUsers> {
  final String? user;

  const PilotUsers({
    this.user,
  });

  static String get table_name => 'pilot_users';
  static String get c_user => 'user';

  static List<PilotUsers> converter(List<Map<String, dynamic>> data) {
    return data.map(PilotUsers.fromJson).toList();
  }

  static PilotUsers converterSingle(Map<String, dynamic> data) {
    return PilotUsers.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? user,
  }) {
    return {
      if (user != null) 'user': user,
    };
  }

  static Map<String, dynamic> insert({
    String? user,
  }) {
    return _generateMap(
      user: user,
    );
  }

  static Map<String, dynamic> update({
    String? user,
  }) {
    return _generateMap(
      user: user,
    );
  }

  factory PilotUsers.fromJson(Map<String, dynamic> jsonn) {
    return PilotUsers(
      user: jsonn['user'] != null ? jsonn['user'].toString() : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      user: user,
    );
  }

  PilotUsers copyWith({
    String? user,
  }) {
    return PilotUsers(
      user: user ?? this.user,
    );
  }
}

class Tournament_rounds implements SupadartClass<Tournament_rounds> {
  final String id;
  final DateTime? createdAt;
  final BigInt? roundNum;
  final String? deck;
  final String tournament;
  final List<String> result;
  final String user;
  final String? matchEndReason;

  const Tournament_rounds({
    required this.id,
    this.createdAt,
    this.roundNum,
    this.deck,
    required this.tournament,
    required this.result,
    required this.user,
    this.matchEndReason,
  });

  static String get table_name => 'Tournament_rounds';
  static String get c_id => 'id';
  static String get c_createdAt => 'created_at';
  static String get c_roundNum => 'round_num';
  static String get c_deck => 'deck';
  static String get c_tournament => 'tournament';
  static String get c_result => 'result';
  static String get c_user => 'user';
  static String get c_matchEndReason => 'match_end_reason';

  static List<Tournament_rounds> converter(List<Map<String, dynamic>> data) {
    return data.map(Tournament_rounds.fromJson).toList();
  }

  static Tournament_rounds converterSingle(Map<String, dynamic> data) {
    return Tournament_rounds.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    DateTime? createdAt,
    BigInt? roundNum,
    String? deck,
    String? tournament,
    List<String>? result,
    String? user,
    String? matchEndReason,
  }) {
    return {
      if (id != null) 'id': id,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (roundNum != null) 'round_num': roundNum.toString(),
      if (deck != null) 'deck': deck,
      if (tournament != null) 'tournament': tournament,
      if (result != null) 'result': result.map((e) => e).toList(),
      if (user != null) 'user': user,
      if (matchEndReason != null) 'match_end_reason': matchEndReason,
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    DateTime? createdAt,
    required BigInt roundNum,
    String? deck,
    required String tournament,
    required List<String> result,
    required String user,
    String? matchEndReason,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      roundNum: roundNum,
      deck: deck,
      tournament: tournament,
      result: result,
      user: user,
      matchEndReason: matchEndReason,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    DateTime? createdAt,
    BigInt? roundNum,
    String? deck,
    String? tournament,
    List<String>? result,
    String? user,
    String? matchEndReason,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      roundNum: roundNum,
      deck: deck,
      tournament: tournament,
      result: result,
      user: user,
      matchEndReason: matchEndReason,
    );
  }

  factory Tournament_rounds.fromJson(Map<String, dynamic> jsonn) {
    return Tournament_rounds(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      roundNum: jsonn['round_num'] != null
          ? BigInt.parse(jsonn['round_num'].toString())
          : BigInt.from(0),
      deck: jsonn['deck'] != null ? jsonn['deck'].toString() : '',
      tournament:
          jsonn['tournament'] != null ? jsonn['tournament'].toString() : '',
      result: jsonn['result'] != null
          ? (jsonn['result'] as List<dynamic>).map((v) => v.toString()).toList()
          : <String>[],
      user: jsonn['user'] != null ? jsonn['user'].toString() : '',
      matchEndReason: jsonn['match_end_reason'] != null
          ? jsonn['match_end_reason'].toString()
          : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      roundNum: roundNum,
      deck: deck,
      tournament: tournament,
      result: result,
      user: user,
      matchEndReason: matchEndReason,
    );
  }

  Tournament_rounds copyWith({
    String? id,
    DateTime? createdAt,
    BigInt? roundNum,
    String? deck,
    String? tournament,
    List<String>? result,
    String? user,
    String? matchEndReason,
  }) {
    return Tournament_rounds(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      roundNum: roundNum ?? this.roundNum,
      deck: deck ?? this.deck,
      tournament: tournament ?? this.tournament,
      result: result ?? this.result,
      user: user ?? this.user,
      matchEndReason: matchEndReason ?? this.matchEndReason,
    );
  }
}

class Feedback implements SupadartClass<Feedback> {
  final BigInt id;
  final DateTime? createdAt;
  final String? userId;
  final String? featureName;
  final String? bugType;
  final String? description;
  final bool? isFixed;
  final String? devNotes;

  const Feedback({
    required this.id,
    this.createdAt,
    this.userId,
    this.featureName,
    this.bugType,
    this.description,
    this.isFixed,
    this.devNotes,
  });

  static String get table_name => 'feedback';
  static String get c_id => 'id';
  static String get c_createdAt => 'created_at';
  static String get c_userId => 'user_id';
  static String get c_featureName => 'feature_name';
  static String get c_bugType => 'bug_type';
  static String get c_description => 'description';
  static String get c_isFixed => 'is_fixed';
  static String get c_devNotes => 'dev_notes';

  static List<Feedback> converter(List<Map<String, dynamic>> data) {
    return data.map(Feedback.fromJson).toList();
  }

  static Feedback converterSingle(Map<String, dynamic> data) {
    return Feedback.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    BigInt? id,
    DateTime? createdAt,
    String? userId,
    String? featureName,
    String? bugType,
    String? description,
    bool? isFixed,
    String? devNotes,
  }) {
    return {
      if (id != null) 'id': id.toString(),
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (userId != null) 'user_id': userId,
      if (featureName != null) 'feature_name': featureName,
      if (bugType != null) 'bug_type': bugType,
      if (description != null) 'description': description,
      if (isFixed != null) 'is_fixed': isFixed,
      if (devNotes != null) 'dev_notes': devNotes,
    };
  }

  static Map<String, dynamic> insert({
    BigInt? id,
    DateTime? createdAt,
    String? userId,
    required String featureName,
    String? bugType,
    String? description,
    bool? isFixed,
    String? devNotes,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      userId: userId,
      featureName: featureName,
      bugType: bugType,
      description: description,
      isFixed: isFixed,
      devNotes: devNotes,
    );
  }

  static Map<String, dynamic> update({
    BigInt? id,
    DateTime? createdAt,
    String? userId,
    String? featureName,
    String? bugType,
    String? description,
    bool? isFixed,
    String? devNotes,
  }) {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      userId: userId,
      featureName: featureName,
      bugType: bugType,
      description: description,
      isFixed: isFixed,
      devNotes: devNotes,
    );
  }

  factory Feedback.fromJson(Map<String, dynamic> jsonn) {
    return Feedback(
      id: jsonn['id'] != null
          ? BigInt.parse(jsonn['id'].toString())
          : BigInt.from(0),
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      userId: jsonn['user_id'] != null ? jsonn['user_id'].toString() : '',
      featureName:
          jsonn['feature_name'] != null ? jsonn['feature_name'].toString() : '',
      bugType: jsonn['bug_type'] != null ? jsonn['bug_type'].toString() : '',
      description:
          jsonn['description'] != null ? jsonn['description'].toString() : '',
      isFixed: jsonn['is_fixed'] != null ? jsonn['is_fixed'] as bool : false,
      devNotes: jsonn['dev_notes'] != null ? jsonn['dev_notes'].toString() : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      createdAt: createdAt,
      userId: userId,
      featureName: featureName,
      bugType: bugType,
      description: description,
      isFixed: isFixed,
      devNotes: devNotes,
    );
  }

  Feedback copyWith({
    BigInt? id,
    DateTime? createdAt,
    String? userId,
    String? featureName,
    String? bugType,
    String? description,
    bool? isFixed,
    String? devNotes,
  }) {
    return Feedback(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      userId: userId ?? this.userId,
      featureName: featureName ?? this.featureName,
      bugType: bugType ?? this.bugType,
      description: description ?? this.description,
      isFixed: isFixed ?? this.isFixed,
      devNotes: devNotes ?? this.devNotes,
    );
  }
}

class Logs implements SupadartClass<Logs> {
  final DateTime? createdAt;
  final String user;
  final String log;
  final String id;
  final String? archetype;

  const Logs({
    this.createdAt,
    required this.user,
    required this.log,
    required this.id,
    this.archetype,
  });

  static String get table_name => 'logs';
  static String get c_createdAt => 'created_at';
  static String get c_user => 'user';
  static String get c_log => 'log';
  static String get c_id => 'id';
  static String get c_archetype => 'archetype';

  static List<Logs> converter(List<Map<String, dynamic>> data) {
    return data.map(Logs.fromJson).toList();
  }

  static Logs converterSingle(Map<String, dynamic> data) {
    return Logs.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    DateTime? createdAt,
    String? user,
    String? log,
    String? id,
    String? archetype,
  }) {
    return {
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (user != null) 'user': user,
      if (log != null) 'log': log,
      if (id != null) 'id': id,
      if (archetype != null) 'archetype': archetype,
    };
  }

  static Map<String, dynamic> insert({
    DateTime? createdAt,
    required String user,
    required String log,
    String? id,
    String? archetype,
  }) {
    return _generateMap(
      createdAt: createdAt,
      user: user,
      log: log,
      id: id,
      archetype: archetype,
    );
  }

  static Map<String, dynamic> update({
    DateTime? createdAt,
    String? user,
    String? log,
    String? id,
    String? archetype,
  }) {
    return _generateMap(
      createdAt: createdAt,
      user: user,
      log: log,
      id: id,
      archetype: archetype,
    );
  }

  factory Logs.fromJson(Map<String, dynamic> jsonn) {
    return Logs(
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      user: jsonn['user'] != null ? jsonn['user'].toString() : '',
      log: jsonn['log'] != null ? jsonn['log'].toString() : '',
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      archetype:
          jsonn['archetype'] != null ? jsonn['archetype'].toString() : '',
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      createdAt: createdAt,
      user: user,
      log: log,
      id: id,
      archetype: archetype,
    );
  }

  Logs copyWith({
    DateTime? createdAt,
    String? user,
    String? log,
    String? id,
    String? archetype,
  }) {
    return Logs(
      createdAt: createdAt ?? this.createdAt,
      user: user ?? this.user,
      log: log ?? this.log,
      id: id ?? this.id,
      archetype: archetype ?? this.archetype,
    );
  }
}
